---
title: 责任链设计模式
date: 2018-09-12 19:18:45
top: 8
tags:
	设计模式
---
　　责任链设计模式属于行为类设计模式，责任链设计模式顾名思义就好比链表一样，不同的是责任链是由多个处理不同任务的对象节点组成，每个对象节点包含着责任链上下一个对象节点的引用，这样请求就可以在这条链上进行传递，直到有一个对象节点可以处理请求，或者每个对象节点都可以处理请求，并传递给下家，直到链上的每个对象节点都处理完，这样就能在不影响客户端的前提下在责任链上任意的更改处理对象节点。
<!-- more -->
# 概述
　　例如我们去政府部门去办事，有时候就会遇见官员责任踢球，这就是一个责任链，你的问题我能够解决我就解决，如果我不能解决就推卸给另一个部门，至于谁最后处理这个事情，政府部门为了将屁民的请求也官员耦合在一起，让多个（部门）都可以接受请求，将这些（部门）对象连接成一条链，并且沿着这条链传递请求，直到有（部门）对象处理它为止。
# 优缺点
* 降低客户段与处理节点的耦合度
* 简化处理节点的相互连接
* 增强了给处理节点指派职责的灵活性
* 简化了如何增加一个处理节点
* `缺点`：不能保证请求一定被接收；且对于比较长的职责链，请求的处理可能涉及到多个处理对象，系统性能将受到一定影响，而且在进行代码调试时不太方便；另外如果使用不恰当容易产生循环调用。

# 结构
![结构](/img/责任链设计模式1.jpg)
　　一个典型的对象结构可能如下图所示：
![结构](/img/责任链设计模式2.jpg)
　　主要有以下三个对象组成：
* Handler(抽象处理者)：定义一个处理请求的接口，和一个后继连接(可选)
* ConcreteHandler(具体处理者)：处理它所负责的请求，可以访问后继者，如果可以处理请求则处理，否则将该请求转给他的后继者。
* Client(客户类)：向一个链上的具体处理者ConcreteHandler对象提交请求。

# 详解
　　责任链按照处理对象处理的方法可以分为两种模式：
　　a) 纯的责任链模式：一个具体处理者角色处理只能对请求作出两种行为中的一个：一个是自己处理（承担责任）；另一个是把责任推给下家。`不允许出现某一个具体处理者对象在承担了一部分责任后又将责任向下传`的情况。请求在责任链中必须被处理，`不能出现无果而终的结局`。
　　b) 不纯的责任链模式：在一个纯的职责链模式里面，一个请求必须被某一个处理者对象所接收；在一个不纯的职责链模式里面，一个请求可以最终不被任何接收端对象所接收。
# 使用场景
　　a) 不纯的责任链模式：
　　Servlet中的过滤器就采用了不纯的责任链模式，FIlter中的FilterChan对象保存了最终到Servlet对象的所有FIlter对象，这些对象存储在ApplicationFIlterChan对象的Fil数组中，在FilterChain链上没执行一个Filter对象，数组的当前计数就会增加1，直到计数等于数组的长度为止，当FilterChain上的所有Filte执行完毕后就会执行Servlet，所以ApplicationFilterChain中会持有Servlet对象的引用。
　　b) 纯的责任链设计模式：